---
title: Tools
description: Define and manage AI agent tools with full type safety
---

# Tools

Tools allow your AI agent to perform actions and retrieve information from external systems. Promptsmith provides a type-safe way to define tools with Zod schemas.

## Understanding Tools

In Promptsmith, tools have two aspects:

1. **Documentation** - Metadata that appears in the system prompt, teaching the AI when and how to use the tool
2. **Execution** (optional) - The actual implementation that runs when the AI requests the tool

This separation allows you to:

- Use tools for documentation only (AI knows they exist, execution handled elsewhere)
- Include execution logic for direct integration with frameworks like Vercel AI SDK
- Mix both approaches in the same application

## Basic Tool Definition

A tool requires three things:

```typescript
import { z } from "zod";

builder.tool({
  name: "get_weather", // 1. Unique identifier
  description: "Get current weather", // 2. What it does
  schema: z.object({
    // 3. Input parameters
    location: z.string(),
  }),
});
```

## Tool Schema

The schema defines the tool's input parameters using Zod. Use `.describe()` to add descriptions that appear in the system prompt:

```typescript
builder.tool({
  name: "search_products",
  description: "Search the product catalog",
  schema: z.object({
    query: z.string().describe("Search query text"),

    category: z
      .enum(["electronics", "clothing", "home"])
      .optional()
      .describe("Filter by category"),

    minPrice: z.number().min(0).optional().describe("Minimum price in USD"),

    maxPrice: z.number().min(0).optional().describe("Maximum price in USD"),

    limit: z
      .number()
      .min(1)
      .max(100)
      .default(10)
      .describe("Maximum results to return (1-100)"),
  }),
});
```

This generates detailed parameter documentation in the system prompt.

## Tool Execution

Add an `execute` function to implement the tool's logic:

```typescript
builder.tool({
  name: "get_weather",
  description: "Get current weather for a location",
  schema: z.object({
    location: z.string().describe("City name or ZIP code"),
    units: z.enum(["celsius", "fahrenheit"]).optional(),
  }),
  execute: async ({ location, units = "celsius" }) => {
    // Parameters are fully typed!
    const response = await fetch(
      `https://api.weather.com/v1/current?location=${location}&units=${units}`
    );
    return response.json();
  },
});
```

**Key Points:**

- `execute` receives typed arguments based on the schema
- Can be `async` or synchronous
- Return value can be any type
- Optional - only needed if you want Promptsmith to handle execution

## Type Safety

TypeScript automatically infers parameter types from the schema:

```typescript
const weatherSchema = z.object({
  location: z.string(),
  units: z.enum(["celsius", "fahrenheit"]).optional(),
});

builder.tool({
  name: "get_weather",
  description: "Get current weather",
  schema: weatherSchema,
  execute: async (args) => {
    // args.location is string
    // args.units is "celsius" | "fahrenheit" | undefined

    // TypeScript error if you try to access non-existent property
    // args.invalidProp // ❌ Error

    return { temperature: 72, units: args.units ?? "celsius" };
  },
});
```

## Complex Schemas

### Nested Objects

```typescript
builder.tool({
  name: "book_flight",
  description: "Book a flight",
  schema: z.object({
    departure: z
      .object({
        airport: z.string().describe("Departure airport code"),
        date: z.string().describe("Departure date (YYYY-MM-DD)"),
        time: z.string().describe("Departure time (HH:MM)"),
      })
      .describe("Departure information"),

    arrival: z
      .object({
        airport: z.string().describe("Arrival airport code"),
        date: z.string().describe("Arrival date (YYYY-MM-DD)"),
        time: z.string().describe("Arrival time (HH:MM)"),
      })
      .describe("Arrival information"),

    passengers: z
      .array(
        z.object({
          firstName: z.string(),
          lastName: z.string(),
          dateOfBirth: z.string(),
        })
      )
      .describe("List of passengers"),
  }),
  execute: async ({ departure, arrival, passengers }) => {
    // Fully typed nested objects
    return await bookFlight(departure, arrival, passengers);
  },
});
```

### Unions and Discriminated Unions

```typescript
builder.tool({
  name: "send_notification",
  description: "Send a notification via email or SMS",
  schema: z.discriminatedUnion("type", [
    z.object({
      type: z.literal("email"),
      to: z.string().email().describe("Email address"),
      subject: z.string().describe("Email subject"),
      body: z.string().describe("Email body"),
    }),
    z.object({
      type: z.literal("sms"),
      to: z.string().describe("Phone number"),
      message: z.string().describe("SMS message (max 160 chars)"),
    }),
  ]),
  execute: async (args) => {
    if (args.type === "email") {
      return await sendEmail(args.to, args.subject, args.body);
    } else {
      return await sendSMS(args.to, args.message);
    }
  },
});
```

### Arrays

```typescript
builder.tool({
  name: "batch_process",
  description: "Process multiple items at once",
  schema: z.object({
    items: z
      .array(z.string())
      .min(1)
      .max(10)
      .describe("Items to process (1-10)"),

    operation: z
      .enum(["uppercase", "lowercase", "reverse"])
      .describe("Operation to perform"),
  }),
  execute: async ({ items, operation }) => {
    return items.map((item) => {
      switch (operation) {
        case "uppercase":
          return item.toUpperCase();
        case "lowercase":
          return item.toLowerCase();
        case "reverse":
          return item.split("").reverse().join("");
      }
    });
  },
});
```

## Writing Good Tool Descriptions

Tool descriptions are crucial - they teach the AI when and how to use your tools.

### ❌ Bad Descriptions

```typescript
// Too vague
description: "Gets weather";

// No context when to use
description: "Search the database";

// Missing important details
description: "Send email";
```

### ✅ Good Descriptions

```typescript
// Clear and specific
description: "Get current weather conditions for a specific location. Use when user asks about temperature, conditions, or weather.";

// Explains when to use
description: "Search the product database. Use when user wants to find products, check availability, or browse the catalog. Returns product name, price, and stock status.";

// Includes important context
description: "Send an email to a user. Requires valid email address. Use for notifications, confirmations, or alerts. Maximum 1000 characters.";
```

### Best Practices

1. **Be specific about purpose**

```typescript
description: "Retrieve user account information including name, email, and preferences. Use when user asks about their profile or account settings.";
```

2. **Mention key parameters**

```typescript
description: "Search documentation by query and optional section filter. Returns matching pages with excerpts and links.";
```

3. **Include constraints**

```typescript
description: "Create a new task in the project management system. Maximum 500 character description. User must be authenticated.";
```

4. **State what it returns**

```typescript
description: "Calculate shipping cost based on weight, destination, and shipping method. Returns cost in USD and estimated delivery date.";
```

## Multiple Tools

Register multiple tools with `.tools()`:

```typescript
const ecommerceTools = [
  {
    name: "search_products",
    description: "Search product catalog",
    schema: z.object({ query: z.string() }),
    execute: async ({ query }) => await searchProducts(query),
  },
  {
    name: "get_product_details",
    description: "Get detailed product information",
    schema: z.object({ productId: z.string() }),
    execute: async ({ productId }) => await getProduct(productId),
  },
  {
    name: "check_inventory",
    description: "Check product stock levels",
    schema: z.object({
      productId: z.string(),
      warehouseId: z.string().optional(),
    }),
    execute: async ({ productId, warehouseId }) =>
      await checkInventory(productId, warehouseId),
  },
];

builder.tools(ecommerceTools);
```

## Documentation-Only Tools

Sometimes you want the AI to know about a tool without implementing execution in Promptsmith:

```typescript
builder.tool({
  name: "charge_credit_card",
  description:
    "Process a credit card payment. Use only after user confirms the amount.",
  schema: z.object({
    amount: z.number().describe("Amount in USD"),
    cardLast4: z.string().describe("Last 4 digits of card"),
  }),
  // No execute function - handled by your application
});
```

This is useful when:

- Tool execution happens in a different part of your application
- You're using a different framework for tool calling
- The tool requires special security or permissions
- You want to show available tools without implementing them yet

## Tool Return Values

Tools can return any type:

```typescript
// Simple value
execute: async ({ city }) => {
  return { temperature: 72, condition: "sunny" };
};

// Array
execute: async ({ query }) => {
  return [
    { id: 1, name: "Product A" },
    { id: 2, name: "Product B" },
  ];
};

// String
execute: async ({ text }) => {
  return "Processed successfully";
};

// Complex object
execute: async ({ userId }) => {
  return {
    user: { id: userId, name: "John" },
    stats: { posts: 42, followers: 150 },
    lastSeen: new Date().toISOString(),
  };
};

// Void/undefined (for actions without return value)
execute: async ({ message }) => {
  await logMessage(message);
  // No return - undefined
};
```

The AI will receive whatever you return and can use it to form its response.

## Error Handling

Handle errors in your tool implementations:

```typescript
builder.tool({
  name: "get_user",
  description: "Retrieve user information",
  schema: z.object({
    userId: z.string(),
  }),
  execute: async ({ userId }) => {
    try {
      const user = await fetchUser(userId);

      if (!user) {
        return {
          error: "User not found",
          code: "USER_NOT_FOUND",
        };
      }

      return {
        success: true,
        user: user,
      };
    } catch (error) {
      return {
        error: "Failed to fetch user",
        code: "SERVER_ERROR",
        message: error.message,
      };
    }
  },
});
```

Return structured error information so the AI can communicate issues to the user.

## Tool Patterns

### Read-Only Tools (Queries)

```typescript
builder.tool({
  name: "get_order_status",
  description: "Check the status of an order",
  schema: z.object({
    orderId: z.string(),
  }),
  execute: async ({ orderId }) => await getOrderStatus(orderId),
});
```

### Write Tools (Commands)

```typescript
builder.tool({
  name: "cancel_order",
  description: "Cancel an existing order. Cannot be undone.",
  schema: z.object({
    orderId: z.string(),
    reason: z.string().optional(),
  }),
  execute: async ({ orderId, reason }) => {
    // Require confirmation
    await cancelOrder(orderId, reason);
    return { success: true, message: "Order cancelled" };
  },
});
```

### Tools with Side Effects

```typescript
builder.tool({
  name: "send_email",
  description: "Send an email to a user. This will immediately send the email.",
  schema: z.object({
    to: z.string().email(),
    subject: z.string(),
    body: z.string(),
  }),
  execute: async ({ to, subject, body }) => {
    await sendEmail(to, subject, body);
    return { sent: true, timestamp: new Date().toISOString() };
  },
});
```

Add warnings in the description for tools with side effects!

### Async Operations

```typescript
builder.tool({
  name: "generate_report",
  description:
    "Generate a comprehensive analytics report. This may take 30-60 seconds.",
  schema: z.object({
    startDate: z.string(),
    endDate: z.string(),
    metrics: z.array(z.string()),
  }),
  execute: async ({ startDate, endDate, metrics }) => {
    // Long-running operation
    const reportId = await startReportGeneration(startDate, endDate, metrics);

    return {
      status: "processing",
      reportId: reportId,
      estimatedTime: "60 seconds",
      checkStatusUrl: `/api/reports/${reportId}/status`,
    };
  },
});
```

## Retrieving Tools

Get registered tools for inspection or use:

```typescript
const builder = createPromptBuilder()
  .tool({ name: "tool1", ... })
  .tool({ name: "tool2", ... });

// Get all tools
const tools = builder.getTools();
console.log(tools.map(t => t.name)); // ["tool1", "tool2"]

// Get specific tool
const weatherTool = tools.find(t => t.name === "get_weather");
if (weatherTool?.execute) {
  const result = await weatherTool.execute({ location: "Paris" });
}
```

## Best Practices

### 1. Use Descriptive Names

```typescript
// ✅ Good
name: "get_weather";
name: "search_products";
name: "send_email_notification";

// ❌ Bad
name: "weather";
name: "search";
name: "send";
```

### 2. Validate Input Thoroughly

```typescript
schema: z.object({
  email: z.string().email(), // Validate format
  age: z.number().min(0).max(120), // Validate range
  country: z.enum(["US", "CA", "UK"]), // Restrict options
  phone: z.string().regex(/^\+?[\d\s-]+$/), // Validate pattern
});
```

### 3. Provide Detailed Descriptions

```typescript
schema: z.object({
  date: z.string().describe("Date in YYYY-MM-DD format"),
  amount: z.number().describe("Amount in USD (e.g., 19.99)"),
  category: z
    .string()
    .describe(
      "Transaction category: groceries, transport, entertainment, etc."
    ),
});
```

### 4. Handle Edge Cases

```typescript
execute: async ({ userId }) => {
  if (!userId) {
    return { error: "userId is required" };
  }

  if (userId.length < 3) {
    return { error: "Invalid userId format" };
  }

  const user = await fetchUser(userId);

  if (!user) {
    return { error: "User not found", userId };
  }

  return { success: true, user };
};
```

### 5. Keep Tools Focused

```typescript
// ✅ Good - Single responsibility
builder
  .tool({ name: "get_user", ... })
  .tool({ name: "update_user", ... })
  .tool({ name: "delete_user", ... });

// ❌ Bad - Too much in one tool
builder.tool({
  name: "user_operations",
  schema: z.object({
    operation: z.enum(["get", "update", "delete"]),
    // ... complex branching logic
  })
});
```

## Next Steps

<Cards>
  <Card
    title="AI SDK Integration"
    href="/docs/ai-sdk-integration"
    description="Use tools with Vercel AI SDK for automatic execution"
  />
  <Card
    title="Builder API"
    href="/docs/builder-api"
    description="Complete API reference for the builder"
  />
</Cards>
